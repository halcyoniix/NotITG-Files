<Layer Type = "ActorFrame" InitCommand = "%m_prefix(function(self) if init then init = nil return end init = true self:playcommand('Set') end)" SetCommand = "%m_prefix(function(self)

init_mods = 'clearall, *-1 overhead, *-1 2x, *-1 zbuffer, approachtype,*-1 200 modtimer, halgun, dizzyholds,*-1 -100 drawsizeback,*-1 stealthtype,*-1 stealthpastreceptors,receptorzbuffer'
GAMESTATE:ApplyModifiers(init_mods)

h_render_target = {aft = {},spr = {}}
fluct = function(i) return math.mod(i,2)*2-1 end

h_c2l = {
	intro_perc = {
		{4.000,0,1},
		{5.000,1,1},
		{7.000,1,1},
		{8.000,0,1},
		{9.000,1,1},
		{11.000,1,1},
		{12.000,0,1},
		{13.000,1,1},
		{15.000,1,1},
		{16.000,0,1},
		{17.000,1,1},
		{19.000,1,1},
		{20.000,0,1},
		{21.000,1,1},
		{23.000,1,1},
		{24.000,0,1},
		{25.000,1,1},
		{27.000,1,1},
		{28.000,0,1},
		{29.000,1,1},
		{31.000,1,1},
		{32.000,0,1},
		{33.000,1,1},
		{35.000,1,1},
		{36.000,0,1},
		{36.000,2,1},
		{37.000,1,1},
		{37.500,2,1},
		{39.000,1,1},
		{39.000,2,1},
		{40.000,0,1},
		{40.500,2,1},
		{41.000,1,1},
		{42.000,2,1},
		{43.000,1,1},
		{44.000,0,1},
		{44.000,2,1},
		{45.000,1,1},
		{45.500,2,1},
		{47.000,1,1},
		{47.000,2,1},
		{48.000,0,1},
		{48.500,2,1},
		{49.000,1,1},
		{50.000,2,1},
		{51.000,1,1},
		{52.000,0,1},
		{53.000,1,1},
		{55.000,1,1},
		{56.000,0,1},
		{57.000,1,1},
		{59.000,1,1},
		{60.000,0,1},
		{61.000,1,1},
		{63.000,1,1},
	}
}

function mods_hal()
mod {0, 9E9, init_mods}
print('hal loaded')
mod {0, function()
	for pn = 1,max_players do
		local a = Plr(pn)
		if a then
			a:GetChild('NoteField'):addy(-10)
			a:hidden(1)
			if pn <= 2 then
				a:GetChild('Judgment'):sleep(9E9)
				a:GetChild('Combo'):sleep(9E9)
				a:hidden(0)
				judgment[pn]:zoom(0.75)
				combo[pn]:zoom(0.75)
			end
			a:SetFarDist(9999)
			a:x(s.scx)
		end
	end
end, persist = true}


mod {0, 4, '*-1 dark,*-1 20 flip,*-1 20 reverse'}
mod {3, 1, '*1 no dark'}

mod {2.5, 1, 0, -400, 'z', ease = inOutCirc}
mod {3.5, 0.5, -400, 0, 'z', ease = inQuad}
mod {4, 6, 50, 0, 'z', ease = outElastic}

mod {3.5, 0.5, 20, 0, 'flip', ease = inQuad}
mod {4, 6, -5, 0, 'flip', ease = outElastic}
mod {3.5, 0.5, 20, 0, 'reverse', ease = inQuad}
mod {4, 6, -5, 0, 'reverse', ease = outElastic}
--hal.join {3.5, 1, -400, 0, 'z', offset = 0.5, inEase = inCirc, outEase = outBack}

funny_pad = function(beat,mult)
	local beat = beat - 0.5
	mod {beat, 0.5, 0, 200*mult, 'drunk', ease = inCirc}
	mod {beat+0.5, 2.5, 200*mult, 0, 'drunk', ease = outSine}
	mod {beat, 3, 2500, 0, 'drunkoffset', ease = outSine}

	mod {beat, 0.5, 0, 500, 'bumpy', ease = inCirc}
	mod {beat+0.5, 2.5, 500, 0, 'bumpy', ease = outSine}

	mod {beat, 0.5, 2, 1, 'xmod', ease = inCirc}
	mod {beat+0.5, 2.5, 1, 2, 'xmod', ease = outSine}

	mod {beat, 0.5, 0, 20*mult, 'rotationy', ease = inCirc}
	mod {beat+0.5, 2.5, 20*mult, 0, 'rotationy', ease = outSine}

	mod {beat, 0.5, 0, 40, 'centered2', ease = inCirc}
	mod {beat+0.5, 2.5, 40, 0, 'centered2', ease = outSine}
end
mod {4, 62, '*-1 -100 drunkspeed,*-1 -20 drunkperiod,*-1 400 bumpyperiod,*-1 200 zoomz'}
for i = 0,3 do
	local m = 8*i
	funny_pad(4+m,fluct(i))
	funny_pad(7.5+m,fluct(i))
end

--hal.wiggle {4, 32, 4, 2, 'rotationz', ease = inOutCirc}


for k,v in pairs(h_c2l.intro_perc) do
	if v[2] == 0 then -- dik
		mod {v[1], 1, 80, 100, 'zoom', ease = outCirc}
	elseif v[2] == 1 then -- litl snail
		mod {v[1], 1, -150, 0, 'tiny', ease = outCirc}
	elseif v[2] == 2 then -- BOOSH
		mod {v[1], 1, -200, 0, 'tipsy', ease = outQuad}
		mod {v[1], 1, -800, 0, 'tinyz', ease = outQuad}
		mod {v[1], 1, 40, 0, 'brake', ease = linear}
	end
end


mod {35, 2, 0, 100, 'reverse', ease = inOutCirc, sustain = 27}
--mod {35, 2, 0, -400, 'parabolaz', ease = inOutExpo, sustain = 27}

mod {35, 2, 0, -40, 'rotationx', ease = inOutExpo, sustain = 27}
mod {35, 2, 100, 400, 'zoomz', ease = inOutExpo}
mod {37, 27, 400, 2000, 'zoomz', ease = inCirc}




mod {39, 2, 0, 100, 'invert', ease = inOutQuad, sustain = 2}
mod {43, 2, 100, 0, 'invert', ease = inOutExpo, sustain = 2}

mod {44, 4, 35, 0, 'stealth', ease = outQuad}

mod {39+8, 2, 0, 100, 'flip', ease = inOutQuad, sustain = 2}
mod {43+8, 2, 100, 0, 'flip', ease = inOutExpo, sustain = 2}

mod {52, 4, 35, 0, 'stealth', ease = outQuad}
mod {52, 12, r(360*12), 0, 'confusionoffset', ease = inCirc}
mod {56, 4, 35, 0, 'stealth', ease = outQuad}

mod {60, 4, 35, 0, 'stealth', ease = outQuad}
mod {60-4, 8, 0, 200, 'boost', ease = inSine}
mod {62, 4, 35, 0, 'stealth', ease = outQuad}
mod {64, 4, '*-1 no boost,*-1 dark0,,*-1 dark1,*-1 dark2,*-1 dark3,*-1 no reverse,*-1 no rotationx,*-1 400 zoomz'}


mod {64, 4, '*-1 stealth', pn = 2}

for i = 0,3 do
	local b = math.floor(i/2)
	mod {64+b, 1, 100, 0, 'dark'..i, ease = outQuad, pn = 2, sustain = 5-i}
	mod {63.5+i, 1, 100-(100/4)*(i), 100-(100/4)*(i+1), 'hallway', ease = inOutCirc}
end

for i = 0,14 do
	mod {5.5+i*4, 4, 140, 100, 'zoomx', ease = outElastic}
	mod {7.5+i*4, 6, 50*fluct(i), 0, 'skewy', ease = outElastic}
end

mod {68, 1, '*-1 no stealth'}

hal.wiggle {64, 2, -200, 1, 'parabolax', ease = inOutCirc, abs = false}
hal.bounce {64.5, 2, 0, 40, 'skewx', inEase = inOutCirc, outEase = inOutCirc}
mod {65, 2, -360, 0, 'rotationz', ease = inOutExpo}
hal.wiggle {64, 2, 100, 1, 'x', ease = inOutCirc, abs = false}

hal.bounce {66.75, 1, 0, -700, 'z', inEase = inOutCirc, inSus = 0.25, outEase = inCirc}
hal.bounce {66.75, 1, 0, 25, 'reverse', inEase = inOutCirc, inSus = 0.25, outEase = inCirc}
hal.bounce {66.75, 1, 0, 20, 'flip', inEase = inOutCirc, inSus = 0.25, outEase = inCirc}




--local t = {0,0.5,1.75,2.5}
o_ha_you_good_mor_ning = function(beat)
	mod {beat, 0.5, '*-1 75 flip,*-1 -125 invert'}
	mod {beat+0.5, 0.5, '*-1 no invert'}
	mod {beat+0.5, 0.5, 100, 0, 'flip', ease = inExpo}
	mod {beat+1, 3, -10, 0, 'flip', ease = outElastic}
	mod {beat+1, 3, 120, 100, 'zoomx', ease = outElastic}
	--mod {beat+1, 3, 20, 0, 'x', ease = outElastic}
	mod {beat+1, 3, 1, 0, function(t)
		local str = ''
		for col = 0,3 do
			str = str .. '*-1 '.. (t.value*1000)*math.sin((t.beat)+(col/3)*math.pi) .. ' movez'.. col ..','
		end
		addmods(str)
	end, ease = outElastic}
	hal.bounce {beat+1, 2, 0, -400, 'z', inEase = outCirc, outEase = inCirc}
	for k,v in pairs({0,0.5,1.75,2.5}) do
		mod {beat+v, 0.5, 125, 100, 'zoom', ease = outCirc}
		mod {beat+v, 1, 50, 0, 'brake', ease = linear}
	end

end

o_ha_you_good_mor_ning(93)



mod {137, 64, '*-1 stealth', pn = 2}
mod {137, 64, '*-1 dark', pn = 1}


mod {140, 234234, '*-1 arrowpath'}
mod {140, 234234, '*2 20000 centered2,*2 -20000 movey'}


local pos = {
	{ 0, 0, 0, 0 },
	{ -200, -200, -200, -200 },
	{ 200, 200, 200, 200 },
}
--[[
mod {137, function()
	local space = 700
	for pn = 1,1 do
		local a = Plr(pn)
		if a then
			a:NoClearSplines(true)
			for i = 1,#pos do
				for col = 0,3 do
					print(i-1, col, pos[i][col+1], space, -1)
					a:SetXSpline(i-1, col, pos[i][col+1], space, -1)
				end
			end
			for k,v in pairs(pos) do
				for col = 0,3 do
					a:SetXSpline((k-1), col, v[col+1], space, -1)
					a:SetXSpline((k-1)+1, col, v[col+1], space+1, -1)
				end
			end
		end
	end
end, persist = true}
--]]










end end)"
OnCommand = "queuecommand,Prepare;luaeffect,Update" PrepareCommand = "%m_prefix.set" UpdateCommand = "%m_prefix.update"><children>






</children></Layer>